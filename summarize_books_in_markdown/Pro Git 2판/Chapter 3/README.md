# 🌈 Chapter 3: Git의 기초

## 🦄 브랜치란 무엇인가

### 🐣 새 브랜치 생성하기
`git branch` 명령으로 `testing` 브랜치 생성   

```bash
> git branch testing
```

새로 만든 브랜치도 지금 작업하고 있던 마지막 커밋을 가리킨다.   

지금 작업 중이 브랜치가 무엇인지 Git은 어떻게 파악할까. 다른 버전 관리 시스템과는 달리 Git은 `HEAD`라는 특별한 포인터가 있다. 이 포인터는 지금 작업하는 로컬 브랜치를 가리킨다. 브랜치를 새로 만들었지만, Git은 아직 `master` 브랜치를 가리키고 있다. `git branch` 명령은 브랜치를 만들기만 하고 브랜치를 옮기지 않는다.

### 🐣 브랜치 이동하기

`git checkout` 명령으로 다른 브랜치로 이동할 수 있다. 한번 `testing` 브랜치로 바꿔보자.

```bash
> git checkout testing
```

이렇게 하면 `HEAD`는 `testing` 브랜치를 가리킨다.   

앞으로 커밋을 하면 다른 브랜치의 작업들과 별개로 진행되기 때문에 `testing` 브랜치에서 임시로 작업하고 원래 `master` 브랜치로 돌아와서 하던 일을 계속할 수 있다.

> 브랜치를 이동하면 워킹 디렉터리의 파일이 변경된다는 점을 기억해두어야 한다. 이전에 작업했던 브랜치로 이동하면 워킹 디렉터리의 파일은 그 브랜치에서 가장 마지막으로 했던 작업 내용으로 변경된다. 파일 변경 시 문제가 있어 브랜치를 이동시키는 게 불가능한 경우 Git은 브랜치 이동 명령을 수행하지 않는다.


프로젝트 히스토리는 분리돼 진행한다. 우리는 브랜치를 하나 만들어 그 브랜치에서 일을 좀 하고, 다시 원래 브랜치로 되돌아와서 다른 일을 했다. 두 작업 내용은 서로 독립적으로 각 브랜치에 존재한다. 커밋 사이를 자유롭게 이동하다가 때가 되면 두 브랜치를 Merge한다.   

실제로 Git의 브랜치는 어떤 한 커밋을 가리키는 40글자의 SHA-1 체크섬 파일에 불과하기 때문에 만들기도 쉽고 지우기도 쉽다. 새로 브랜치를 하나 만드는 것은 41바이트 크기의 파일을 하나 만드는 것에 불과하다.   
커밋을 할 때마다 이전 커밋의 정보를 저장하기 때문에 Merge할 떄 어디서부터 합쳐야 하는지 안다.

## 🦄 브랜치와 Merge의 기초

> 1. 작업 중인 웹사이트가 있다.
> 2. 새로운 이슈를 처리할 새 Branch를 하나 생성한다.
> 3. 새로 만드는 Branch에서 작업을 진행한다.

이때 중요한 문제가 생겨서 그것을 해결하는 Hotfix를 먼저 만들어야 한다. 그러면 아래와 같이 할 수 있다.

> 1. 새로운 이슈를 처리하기 이전의 운영 브랜치로 이동한다.
> 2. Hotfix 브랜치를 새로 하나 생성한다.
> 3. 수정한 Hotfix 테스트를 마치고 운영 브랜치로 Merge한다.
> 4. 다시 작업하던 브랜치로 옮겨가서 하던 일을 진행한다.

### 🐣 브랜치의 기초

브랜치를 이동하려면 해야 할 일이 있다. 아직 커밋하지 않은 파일이 Checkout할 브랜치와 충돌 나면 브랜치를 변경할 수 없다. 브랜치를 변경할 때에는 워킹 디렉터리를 정리하는 것이 좋다. 작업하던 것을 모두 커밋하고 `master` 브랜치로 옮긴다.   

Merge할 브랜치가 가리키는 커밋이 현 브랜치 커밋의 Upstream 브랜치이기 때문에 master 브랜치 포인터는 Merge 과정 없이 그저 최신 커밋으로 이동한다. 이런 Merge 방식을 `Fast Forward`라고 부른다. 다시 말해 A 브랜치에서 다른 B 브랜치를 Merge할 때 B 브랜치가 A 브랜치 이후 커밋을 가리키고 있으면 그저 A 브랜치가 B 브랜치와 동일한 커밋을 가리키도록 이동시킬 뿐이다.   

더 이상 필요없는 `hotfix` 브랜치는 삭제한다. `git branch` 명령어에 `-d` 옵션을 주고 브랜치를 삭제한다.

```bash
> git branch -d hotfix
```

### 🐣 Merge의 기초

`hotfix`를 Merge했을 때와 메시지가 다르다. 현재 브랜치가 가리키는 커밋이 Merge할 브랜치의 조상이 아니므로 Git은 `Fast-forward`로 Merge하지 않는다. 이 경우에는 Git은 각 브랜치가 가리키는 커밋 두 개와 공통 조상 하나를 사용하여 3-way Merge를 한다.   

단순히 브랜치 포인터를 최신 커밋으로 옮기는 게 아니라 3-way Merge의 결과를 별도의 커밋으로 만들고 나서 해당 브랜치가 그 커밋을 가리키도록 이동시킨다. 그래서 이런 커밋은 부모가 여러 개고 Merge 커밋이라고 부른다.   

Git은 Merge하는데 필요한 최적의 공통 조상을 자동으로 찾는다.

### 🐣 충돌의 기초
가끔 3-way Merge가 실패할 때도 있다. Merge하는 두 브랜치에서 같은 파일의 한 부분을 동시에 수정하고 Merge하면 Git은 해당 부분을 Merge하지 못한다. 이럴 경우 충돌(Conflict) 메시지를 출력한다.   

Git이 자동으로 Merge하지 못했기에 새 커밋이 생기지 않는다. 변경사항의 충돌을 개발자가 해결하지 않는 한 Merge 과정을 진행할 수 없다. Merge 충돌이 일어났을 때 Git이 어떤 파일을 Merge할 수 없었는지 살펴보려면 `git status` 명령을 이용한다.   

충돌이 일어난 파일은 `unmerged` 상태로 표시된다. Git은 충돌이 난 부분을 표준 형식에 따라 표시해준다. 그러면 개발자는 해당 부분을 수동으로 해결한다. 이렇게 충돌한 부분을 해결하고 `git add` 명령으로 다시 Git에 저장한다.

## 🦄 브랜치 관리
`git branch` 명령은 단순히 브랜치를 만들고 삭제하는 것이 아니다. 아무런 옵션 없이 실행하면 브랜치의 목록을 보여준다.   

`git branch -v` 명령을 실행하면 브랜치마다 마지막 커밋 메시지도 함꼐 보여준다.   

각 브랜치가 지금 어떤 상태인지 확인하기에 좋은 옵션도 있다. 현재 Checkout 한 브랜치를 기준으로 `--merged`와 `--no--merged` 옵션을 사용하며 Merge된 브랜치인지 그렇지 않은 브랜치인지 필터링해 볼 수 있다. `git branch --merged` 명령어로 이미 Merge한 브랜치 목록을 확인한다.
