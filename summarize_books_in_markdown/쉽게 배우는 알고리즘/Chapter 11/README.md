# 🌈 Chapter 11: 그리디

## 📚 전형적인 그리디 알고리즘의 구조
- 눈앞의 이익만 우선 추구하는 알고리즘을 총칭해서 그리디 알고리즘이라 한다.
- 그리디 알고리즘은 대부분의 경우 뛰어난 결과를 도출하지 못하지만 드물게 최적해를 보장하는 경우도 있다.
- 그리디 알고리즘은 최적화 문제를 대상으로 한다. 최적해를 찾을 수 있으면 그것을 목표로 삼고, 찾기 어려운 경우에는 주어진 시간 내에 그런대로 괜찮은 해를 찾는 것을 목표로 삼는다.
- 전형적인 그리디 알고리즘의 구조다.

```
do {
  가장 좋아 보이는 선택을 한다;
} until (해 구성 완료)
```

- 최소 신장 트리 문제에서는 간선을 하나 더할 때마다 해당 간선이 기존에 선택된 간선들과 사이클을 이루지는 않는지 확인해야 한다.
- 최소 신장 트리를 찾는 그리디 알고리즘 중 하나인 프림 알고리즘이다.

```
Prim(G, r)
// G = (V, E): 주어진 그래프
// r: 시작 정점
// d[]: 각 정점을 신장 트리에 포함시키는 데 드는 최소 비용을 구하기 위한 것
// tree[v]: 현재까지 계산 결과 정점 v를 신장 트리에 연결시키는 비용이 가장 적게 드는 간선을 저장한다. (실제로는 해당 간선에서 v의 맞은편에 있는 정점을 저장한다.)
{
  S <- Ø; // S: 정점 집합
  for each u ∈ V
    d[u] <- ∞;
  d[r] <- 0;

  while (S != V) { // n회 순환
    u <- extractMin(V - S, d); // 가중치가 가장 적은 정점 u
    S <- S ∪ {u}; // S 정점 집합에 포함 시킨다.
    for each v ∈ L(u) // L(u): 정점 u의 인접 정점 집합
      // 가중치(w(u, v)) 값이 정점(d[v])의 최소 비용보다 작고, 
      // 정점이 S에 속하지 않고, 방문하지 않은 것 (v ∈ V - S)
      if (v ∈ V - S and w(u, v) < d[v]) then {
        d[v] <- w(u, v); // 정점의 최소 비용을 바꿔준다.
        tree[v] <- u;
      }
  }
}

extractMin(Q, d[])
{
  // 집합 Q에서 d 값이 가장 작은 정점 u를 리턴한다;
}
```

- 간선의 집합 `d`는 공집합으로 시작해 알고리즘이 끝나면 `n - 1`개의 간선을 포함하게 되고 그것이 최적해가 된다.

```
Greedy(C)
// C: 원소들의 총 집합
{
  S <- Ø;
  while (C != Ø and S는 아직 온전한 해가 아님) {
    x <- C에서 원소 하나 선택;
    집합 C에서 x를 제거한다;
    if (S에 x를 더해도 됨) then S <- S ∪ {x};
  }
  if (S가 온전한 해임) then return S;
                    else return "해 없음!";
}
```

## 📚 그리디 알고리즘으로 최적해가 보장되지 않는 예
- 그리디 알고리즘은 대부분의 경우 최적해를 보장하지 못한다.

### 🎈 이진 트리의 최적합 경로 찾기
- 각 노드가 양의 가중치를 갖고 있는 이진 트리가 있다. 트리의 내용은 사전에 알지 못한다. 루트부터 시작해 왼쪽으로 분기할지 오른쪽으로 분기할지를 매 단계마다 결정해야 한다.
- 임의의 노드에 이르면 그제서야 그 노트의 자식에 할당된 가중치가 공개된다. 이렇게 내려가다 리프 노드를 만나면 끝난다. 이 과정에서 만난 노드에 있는 가중치 합이 이 경로의 점수다. 이 합을 최대화하는 알고리즘을 찾아야 한다.
- 이 문제는 최적해를 보장할 수 없는데 가보지 않은 어떤 노드가 다른 모든 경로의 합보다 큰 가중치를 갖고 있을 가능성이 있기 때문에 모든 노드를 보기 전에는 최적해를 보장할 수 없다.
- 그러므로 루트로부터 DFS와 같은 백트래킹 탐색을 할 수밖에 없고, 수행 시간의 상한은 트리의 총 노드 수에 비례하게 된다.
- 이 문제는 DFS나 BFS와 같은 방식으로 모든 노드를 다 확인해보기 전에는 최적해를 보장할 수 없다.

### 🎈 보따리 문제
- 부피가 M인 보따리(냅색)와 보따리에 넣으려 하는 n개의 물건이 있다. 물건 i의 부피는 W이고 이것을 보따리에 넣을 경우 P의 가치가 있다. 물건들의 전체 부피 합이 M을 넘지 않도록 하면서 가치가 최대가 되도록 보따리에 물건들을 넣어보자.
- 이 방식의 그리디 알고리즘은 최적해를 보장하지 못한다. 이 문제는 NP-Hard에 속하는 난제다. 이 문제를 0/1 보따리 문제라고 한다.
- 보따리 문제에서 물건을 자를 수 있다면 이 같은 방식으로 최적해를 보장할 수 있다. 즉, 단위 부피당 가치가 가장 큰 물건 순서로 각 물건을 보따리에 추가하다가 어떤 물건을 넣으려는 순간 보따리 용량을 초과하면 남은 용량에 들어갈 만큼만 잘라넣으면 된다. 그러면 최적해가 된다. 이 유형을 보따리 문제를 자를 수 있는 보따리 문제라 한다.

### 🎈 동전 바꾸기
- 500원, 100원, 50원, 10원, 5원, 1원 여섯 가지 동전이 있다.
- 3,256원을 가장 적은 개수의 동전을 사용해 만들려면 먼저 500원을 쓸 수 있는 데까지 쓰면 6개가 된다. 다음 100원 2개, 50원 1개, 5원 1개, 1원 1개로 하면 총 11개의 동전으로 3,256원을 만들 수 있다. 이것은 최적해다. 이처럼 동전을 액면이 커지면서 바로 아래 액면의 배수가 되는 경우에는 그리디한 방식으로 최적해를 구할 수 있다.
- 그렇지만 동전의 액면이 증가하면서 앞 액면의 배수가 되지 않는 경우에는 그리디한 방법으로 최적해가 보장되지 않는다. 예를 들어 동전의 액면이 500원, 400원, 100원, 75원, 50원일 경우이다. 이 문제는 동적 프로그래밍으로 최적해를 구할 수 있다.

## 📚 그리디 알고리즘으로 최적해가 보장되는 예

### 🎈 최소 신장 트리
- 최소 신장 트리를 위한 프림 알고리즘, 크루스칼 알고리즘은 그리디 알고리즘으로 최적해가 보장되는 예이다.
- 최소 신장 트리는 어떤 시점이든지 그 시점에서 집합 S에 가장 싼 비용으로 연결되는 정점을 택한다.

### 🎈회의실 배정 문제
- 회사에 회의실이 1개 있다. 여러 부서에서 회의실을 사용하므로 미리 신청을 받아 스케줄링을 한다. 회의실을 사용하고자 하는 부서는 원하는 회의 시작 시간과 종료 시간을 명시해서 신청서를 제출한다. 이렇게 받은 n개의 회의 신청에 대해 회의실 사용 스케줄을 정하려 한다. 목표는 겹치는 회의가 없게 하면서 가장 많은 수의 회의를 소화할 수 있도록 하는 것이다. 구현의 편의를 위해 앞 회의의 종료 시간과 바로 다음 회의의 시작 시간이 같아도 된다.

```
Greedy_Schedule(S, n)
// S = {(si, ti)} n: 신청 회의 수
// si: 시작 시간, ti: 종료 시간
{
  t(종료 시간)에 대한 오름차순으로 정렬하고, 이 순서대로 번호를 다시 매긴다; -> 즉, 종료 시간이 가장 이른 회의가 (s1, t1)이 된다.
  T <- {1}; // 결과 집합 <- 번호
  last <- 1; // 종료시간이 제일 빠름
  for (i <- 2, i <= n, i++)
    if (tlast <= si) { // 이전 끝난 시간보다 현재 시작 시간이 크면
      T <- T ∪ {i}; // i는 T에 포함
      last <- i; // i는 last
    }
  return T;
}
```

- JavaScript 회의실 배정 예제

```js
const toEndTimeAsc = (a, b) => {
  if (a[1] === b[1]) {
    return a[0] - b[0];
  }

  return a[1] - b[1];
};

function meetingRoomAssignment(meeting) {
  const sortedMeeting = [...meeting].sort(toEndTimeAsc);
  let result = 0;
  let end = 0;

  sortedMeeting.forEach(([start, finish]) => {
    if (end <= start) {
      end = finish;
      result += 1;
    }
  });

  return result;
}
```

### 🎈 그 밖의 예
- 그래프에서 최단 경로를 구하는 다익스트라 알고리즘도 그리디 알고리즘이다.
- 문서에서 각 원소들의 출현 빈도가 주어질 때 해당 문서를 효율적으로 압축하는 코드를 만드는 허프만 코딩 알고리즘도 그리디 알고리즘이다.
