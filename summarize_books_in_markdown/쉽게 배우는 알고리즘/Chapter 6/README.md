# 🌈 Chapter 6: 검색 트리

## 📚 레코드, 키의 정의 및 검색 트리
- 레코드는 개체에 대한 모든 정보를 포함하고 있다. 사람의 레코드라면 주민번호, 이름, 집 주소, 전화번호등 정보가 포함될 수 있다. 이 각각의 정보를 나타내는 부분을 필드라고 한다.
- 검색 트리는 한 노드에서 최대 몇 개의 자식 노드로 분기를 할 수 있느냐에 따라 이진 검색 트리와 다진 검색 트리로 나눈다. 이진 검색 트리는 최대 두 개의 자식 노드를 가질 수 있고, 다진 검색 트리는 세 개 이상의 자식 노드로 분기할 수 있다.
- 검색 트리는 저장되는 장소에 따라 내부 검색 트리와 외부 검색 트리로 나눈다.
- 검색 트리는 검색키가 포함하는 필드의 수에 따라 일차원 검색 트리와 다차원 검색 트리로 나눈다. 키를 구성하는 필드가 하나이면 일차원 검색 트리, 두 개 이상이면 다차원 검색 트리다.

## 📚 이진 검색 트리
- 이진 검색 트리에는 다음과 같은 특징이 있다.

> 1. 이진 검색 트리의 각 노드는 키 값을 하나씩 갖는다. 각 노드의 키 값은 모두 달라야 한다.
> 2. 최상위 레벨에 루트 노드가 있고, 각 노드는 최대 두 개의 자식 노드를 갖는다.
> 3. 임의의 노드의 키 값은 자신의 왼쪽에 있는 모든 노드의 키 값보다 크고, 오른쪽에 있는 모든 노드의 키 값보다 작다.

### 🎈 이진 검색 트리에서 검색
- 이진 검색 트리에서 키가 x인 노드를 검색하고자 한다. 트리에 키가 x인 노드가 존재하면 해당 노드를 리턴하고, 존재하지 않으면 NIL을 리턴한다.

```
treeSearch(t, x)
// t: 트리의 루트 노드
// x: 검색하고자 하는 키
{
  if (t = NIL or key[t] = x) then return t;
  if (x < key[t])
    then return treeSearch(left[t], x);
    else return treeSearch(right[t], x);
}
```

### 🎈 이진 검색 트리에서 삽입
- 원소 x를 이진 검색 트리에 삽입하려면 우선 이진 검색 트리에 x를 키 값으로 가진 노드가 없어야 한다.
- 원소 x를 삽입할 자리를 찾기 위해서는 우선 실패하는 검색을 한 번 수행해야 한다. 즉, 루트 노드에서 x에 대한 검색을 수행해 임의의 리프 노드에 이르러 더 이상 내려갈 곳이 없음이 확인되면 x를 그 리프 노드의 자식으로 매단다.
- 이진 검색 트리의 모양은 원소들이 삽입되는 순서에 따라 결정된다.

```
treeInsert(t, x)
// t: 트리의 루트 노드
// x: 삽입하고자 하는 키
// 작업 완료 후 루트 노드의 포인터를 리턴한다;
{
  if (t = NIL) then {
    // r: 새 노드
    key[r] <- x;
    left[r] <- NIL;
    right[r] <- NIL;
  }
  if (x < key[t])
    then {
      left[t] <- treeInsert(left[t], x);
      return t;
    }
    else {
      right[t] <- treeInsert(right[t], x);
      return t;
    }
}
```

- n개의 원소로 이진 검색 트리를 만들 때, 이진 검색 트리가 가장 이상적으로 균형이 잡히면 최악의 경우라 하더라도 검색 시간은 ɵ(logn)이다. 가장 나쁘게 기울면 평균 검색 시간이 ɵ(n)이 된다.
- 가능한 모든 삽입 순서에 따른 이진 검색 트리를 모두 고려하면 평균 검색 시간은 ɵ(logn)이다.

### 🎈 이진 검색 트리에서 삭제
- 이진 검색 트리에서 노드 r을 삭제하고자 할 때는 다음 세 가지 경우에 따라 각각 다르게 처리를 해주어야 한다.

> - Case 1: r이 리프 노드인 경우
> - Case 2: r의 자식 노드가 하나인 경우
> - Case 3: r의 자식 노드가 두 개인 경우

- r의 자식 노드가 두 개인 경우에 r 자리에 옮겨놓아도 이진 검색 트리의 성질을 전혀 깨지 않는 원소를 찾는다. 이런 원소는 트리 전체에서 딱 두 개 있다. 바로 r의 왼쪽 서브 트리에서 가장 큰 원소와 r의 오른쪽 서브 트리에서 가장 작은 원소다. 둘 중 하나를 택해 키를 r자리로 옮긴다. 그런 다음 직후 원소가 들어 있던 노드를 삭제한다.

```
treeDelete(t, r, p)
// t: 트리의 루트 노드
// r: 삭제하고자 하는 노드, p: r의 부모 노드
{
  // r이 루트 노드인 경우
  if (r = t) then root <- deleteNode(t);
  // r이 루트 노드가 아닌 경우
  else if (r = left[p])
    then left[p] <- deleteNode(r); // r이 p의 왼쪽 자식
    else right[p] <- deleteNode(r); // r이 p의 오른쪽 자식
}
deleteNode(r)
{
  if (left[r] = right[r] == NIL) then return NIL; // Case 1
  else if (left[r] = NIL and right[r] != NIL) then return right[r]; // Case 2-1
  else if (left[r] != NIL and right[r] = NIL) then return left[r]; // Case 2-2
  else {
    s <- right[r]; // r의 오른쪽 서브 트리
    while(left[s] != NIL) { // s의 왼쪽자식이 존재하지 않을 때까지 (즉, 왼쪽 서브트리에서 가장 작은 값을 찾는다.)
      parent <- s; // s를 부모로 변경
      s <- left[s]; // s는 s의 왼쪽 자식으로 변경
    }
    key[r] <- key[s];
    if (s = right[r]) then right[r] <- right[s]; // r의 오른쪽 서브트리는 s의 오른쪽 서브트리로 변경
                      else left[parent] <- right[s]; // s 부모의 왼쪽값은 s의 오른쪽 서브트리로 변경
    return r;
  }
}
```

- 삭제 작업의 수행 시간은 Case 1과 Case 2는 상수 시간이 든다. Case 3은 노드 r의 직후 원소를 찾는데 최악의 경우 트리의 높이에 비례하는 시간이 든다. 삭제 작업을 위한 최악의 시간은 트리의 높이에 따라 O(logn)과 O(n) 사이에 결정된다.

## 📚 레드 블랙 트리
- 이진 검색 트리는 저장과 검색에 평균 ɵ(logn) 시간이 소요되지만 운이 나쁘면 트리의 모양이 균형을 잘 이루지 못한다. 균형이 많이 깨지면 ɵ(n)에 근접한 시간이 소요될 수도 있다. 그래서 고안해낸 것이 균형잡힌 이진 검색 트리다.
- 균형잡힌 이진 검색 트리로 대표적인 것은 레드 블랙 트리와 AVL 트리다.
- 레드 블랙 트리는 이진 검색 트리의 모든 노드에 레드 또는 블랙의 색상을 칠한다. 단, 다음 성질을 만족하도록 색칠을 칠해야 하는데 이를 레드 블랙 특성이라 한다.

> 1. 루트는 블랙이다.
> 2. 모든 리프(NIL)은 블랙이다.
> 3. 노드가 레드이면 그 노드의 자식은 반드시 블랙이다.
> 4. 루트 노드에서 임의의 리프 노드에 이르는 경로에서 만나는 블랙 노드의 수는 모두 같다.

- 여기서 말하는 리프 노드는 일반적으로 말하는 리프 노드와 의미가 다르다. 이진 검색 트리의 노드가 가진 두 개의 자식 포인터 중 NIL인 것이 있으면 노드를 하나 만들어 그것을 리프 노드라 한다.
- 레드 블랙 트리에서 검색은 트리의 내용을 건들지 않으므로 이진 검색 트리에서 검색과 동일하다.
- 삽입과 삭제도 기본적으로는 이진 검색 트리와 동일하지만 삽입이나 삭제 후 레드 블랙 특성을 위반하는 경우가 발생할 수 있다.

### 🎈 레드 블랙 트리에서 삽입
- 레드 블랙 트리에서 노드를 삽입할 때는 먼저 이진 검색 트리의 삽입 알고리즘에 따라 삽입을 한 다음 **새 노드의 색상을 레드**로 색칠한다. 이 노드를 x라 하고, 새 노드는 항상 맨 아래쪽에 매달리므로 삽입 직후에 x의 아래쪽은 블랙 노드인 리프 2개만 있어 레드 블랙 특성에서 문제가 생기지 않는다. x의 위쪽과 관련해서 문제가 생기는지만 확인하면 된다.
- x의 부모 노드 p가 블랙이면 그것으로 삽입은 완료된다. 그러므로 p가 레드인 경우에만 해결하면 된다.
- p가 레드이면 레드 노드가 2개 연속으로 있으므로 레드 블랙 특성을 위반한다. 그런데 삽입 전에는 레드 블랙 트리였으므로 특성 3에 따라 x의 형제 노드도 반드시 블랙이다. x 주변에서 레드나 블랙 두 가지가 다 가능한 것은 p의 형제 노드 s뿐이다. s의 색상에 따라 다음 두 가지 경우로 나눈다.

> - Case 1: s가 레드
> - Case 2: s가 블랙
>     - Case 2-1: x가 p의 오른쪽 자식
>     - Case 2-2: x가 p의 왼쪽 자식

#### 👉 Case 1
- p와 s의 색상을 레드에서 블랙으로 바꾸고, p<sup>2</sup>의 색상을 블랙에서 레드로 바꾼다. p<sup>2</sup>가 루트이면 p<sup>2</sup> 색상을 다시 블랙으로 바꾸고 끝난다. 
- p<sup>2</sup>가 루트가 아니면 p<sup>2</sup>의 부모 색상을 확인해야 한다. p<sup>2</sup> 부모 색상이 블랙이면 레드 블랙 특성이 모두 만족된다. 
- p<sup>2</sup>의 부모 색상이 레드이면 레드 블랙 특성이 위반되어 처음과 똑같은 문제가 발생한다
- 그렇기 때문에 재귀적으로 문제를 해결한다.

#### 👉 Case 2
- Case 2-1
  - P를 중심으로 왼쪽으로 회전한다. 여전히 레드 블랙 특성을 위반한다. Case 2-2로 이동한다.
- Case 2-2
  - p<sup>2</sup>를 중심으로 오른쪽으로 회전하고 p와 p<sup>2</sup>의 색상을 맞바꾼다.
- Case 2를 만나면 Case 2-2의 수선을 마지막으로 상황이 종료된다. Case 1을 만나면 상황이 끝날 수도 있고 똑같은 상황이 다른 노드에서 다시 시작될 수도 있다. 이런 상황이 재귀적으로 반복되어 루트까지 올라갈 수도 있다.

### 🎈 레드 블랙 트리에서 삭제
- 레드 블랙 트리에서 노드를 삭제할 때는 기본적으로 이진 검색 트리에서 삭제 방법에 따라 노드를 삭제한 후 색상을 맞추어준다.
- 최소 원소 노드 m을 삭제한 후 m 주변의 레드 블랙 특성의 위반 여부가 문제가 발생한다. 최소 원소 노드 m은 왼쪽 자식이 없다. 따라서 **최소 원소 노드 m은 최대 한 개의 자식만을 가질 수 있으므로 두 개의 자식을 가진 노드의 삭제 작업은 자식이 없거나 한 개만을 가진 노드의 삭제 작업으로 귀결된다.**
- 따라서 레드 블랙 트리에서 삭제 작업은 자식이 없거나 한 개만을 가진 노드의 삭제에 귀한해 설명해도 무방하다.
- 삭제하려고 하는 노드 m의 자식을 x라고 한다. **자식이 없으면 x는 NIL 노드가 삭제된다.**
- **m이 레드이면 삭제 후 아무런 조치가 필요 없다** 레드 블랙 특성을 깨지 않는다. 따라서 m이 블랙인 경우만 고려하면 된다.
- **m이 블랙이더라도 x가 레드면 삭제 후 x의 색상을 블랙으로 바꾸어버리면 레드 블랙 특성을 만족한다.** m의 부모 노드 색상은 어떤 색이든 상관없다. 그러므로 까다로운 경우는 m과 x의 색상이 모두 블랙일 때다.
- m과 x가 블랙인 상태에서 m이 삭제되면 x는 m의 부모 p의 자식이 되고 루트에서 x를 통과하는 경로의 블랙 노드 개수가 한 개 모자라서 레드 블랙 특성 4가 깨진다.

## 📚 B-트리
- 검색 트리가 디스크에 있는 상태로 사용되면 외부 검색 트리가 한다. 그리고 분기의 수가 2개를 넘으면 다진 검색 트리라 한다.
- B-트리는 디스크 환경에서 사용하기에 적합한 외부 다진 검색 트리다. B-트리의 한 노드에는 최대 k개까지 키가 크기 순으로 저장되어 있다.
- B-트리는 균형잡힌 다진 검색 트리로 다음 성질을 만족한다.

> - 루트를 제외한 모든 노드는 k/2 ~ K개의 키를 갖는다. (ex. 2 ~ 5)
> - 모든 리프 노드는 같은 깊이를 가진다.

- B-트리는 분기의 수를 가능하면 늘리되 균형을 맞추기 위해 각 노드가 채울 수 있는 최대 허용량의 반 이상의 키는 채워야 하는 검색 트리다. B-트리에서 k의 값은 키의 크기와 분기를 위한 포인터에 필요한 공간의 양을 반영하여 디스크의 한 블록이 수용할 수 있는 한도 내에서 최댓값을 잡는다.
- 자식 노드로의 포인터, 부모 노드의 페이지, p<sub>i<sub>들은 모두 페이지 번호로 나타낸다. 예를 들어, 디스크의 한 블록이 8,192바이트고, 키의 크기가 16바이트, 페이지 번호가 4바이트를 차지한다면, 최대 341개의 키 값을 가질 수 있다. 이 경우 각 노드는 170 ~ 341개의 키를 갖는다.
- 이렇게 **디스크 블록의 크기와 노드의 크기를 일치시키는 것은 디스크에서 정보를 읽어올 때는 블록(페이지) 단위로 읽어오기 때문에 최대한 효율을 높이기 위해서이다.**
- p<sub>i</sub>들은 디스크에서 레코드의 구체적인 위치가 아니고 해당 레코드가 저장된 페이지 번호로 P<sub>i</sub>를 통째로 메인 메모리로 가져온 후 그 안에서 해당 레코드를 찾아서 처리한다. 메인 메모리에서 해당 레코드를 찾기 위해 간단한 프로그램이 필요하지만 이것은 디스크에서 가져오는 시간에 비하면 무시할 수 있는 정도로 작은 시간이다.

### 🎈 B-트리에서 검색
- B-트리에서 x에 대한 검색은 기본적으로 이진 검색 트리에서 검색과 같다.
- B-트리에서는 노드의 여러 키 중 검색키와 일치하는 것이 있는지 확인한다. B-트리에서는 key<sub>i-1</sub> < x < key<sub>i</sub>인 두 키를 찾아 분기를 해야 할 지식을 찾는다. 자식으로 분기를 하고 나면 갚이만 하나 내려간 똑같은 검색 문제가 된다. 이것은 이진 검색 트리에서처럼 재호출로 처리할 수 있다.

### 🎈 B-트리에서 삽입
- B-트리에서 키 x를 삽입하는 작업의 개략적인 골격은 다음과 같다.

> 1. x를 삽입할 리프 노드 r을 찾는다.
> 2. 노드 r에 공간의 여유가 있으면 키를 삽입하고 끝낸다.
> 3. 노드 r에 여유가 없으면 형제 노드를 살펴 공간의 여유가 있으면 형제 노드에 키를 하나 넘기고 끝낸다.
> 4. 형제 노드에 여유가 없으면 가운데 키를 부모 노드로 넘기고 노드를 두 개로 분리한다. 부리 작업은 부모 노드에서의 삽입 작업을 포함한다.

```
// B-트리에서 삽입 스케치
Sketch-BTreeInsert(t, x)
// t: 트리의 루트 노드
// x: 삽입하고자 하는 키
{
  x를 삽입할 리프 노드 r을 찾는다;
  x를 r을 삽입한다;
  if (r에 오버플로 발생) then clearOverflow(r);
}
clearOverflow(r)
{
  if (r의 형제 노드 중 공간 여유가 있는 노드가 있음) then {
    r의 남는 키를 넘긴다;
  } else {
    r을 둘로 분할하고 가운데 키를 부모 노드로 넘긴다;
    if (부모 노드 p에 오버플로 발생) then clearOverflow(p);
  }
}
```

### 🎈 B-트리에서 삭제
- B-트리에서 키 x를 삭제하는 작업의 개략적인 골격은 다음과 같다.

> 1. x를 키로 갖고 있는 노드를 찾는다.
> 2. 이 노드가 리프 노드가 아니면 x의 직후 원소 y를 가진 리프 노드 r을 찾아 x와 y를 맞바꾼다.
> 3. 리프 노드에서 x를 제거한다.
> 4. x를 제거 후 노드 언더플로가 발생하면 적절히 해소한다.

- 언더플로가 발생할 때는 우선 키를 가져올 수 있는 형제 노드가 있는지 본다. 그런 노드가 있으면 가져다 채우고 끝낸다. 그렇지 않으면 형제 노드와 병합을 해야 한다. 병합은 두 노드를 하나로 합치는 것이므로 부모 노드의 키 중 하나가 필요 없다. 이 필요 없는 키와 두 노드를 합쳐 하나의 노드로 만든다. 이 병합의 결과키가 하나 줄어든 부모 노드에서 언더 플로가 발생할 수 있다. 이를 재귀적으로 처리할 수 있다.

```
Sketch-BTreeDelete(t, x, v)
// t: 트리의 루트 노드
// x: 삭제하고자 하는 키, v: x를 갖고 있는 노드
{
  if (v가 리프 노드 아님) then {
    x의 직후 원소 y를 가진 리프 노드를 찾는다;
    x와 y를 맞바꾼다;
  }
  리프 노드에서 x를 제거하고 이 리프 노드를 r이라 한다;
  if (r에서 언더플로 발생) then clearUnderflow(r);
}
clearUnderflow(r)
{
  if(r의 형제 노드 중 키를 하나 내놓을 수 있는 여분을 가진 노드가 있음) then {
    r이 키를 넘겨받는다;
  } else {
    r의 형제 노드와 r을 병합하고 부모 노드에서 키를 하나 받는다;
    if (부모 노드 p에 언더플로 발생) then clearUnderflow(p);
  }
}
```

### 🎈 B-트리의 작업 성능 분석
- 이진 검색 트리가 균형을 아주 잘 맞추면 높이가 log<sub>2</sub>n에 근접할 수 있다. 마찬가지로 이진 검색 트리가 균형을 아주 잘 맞추면 높이가 log<sub>2</sub>n에 근접할 수 있다.
- B-트리에서 작업들의 수행 시간은 디스크 접근 횟수를 기준으로 한다.
- B-트리에서 검색은 당연히 O(logn)이다. 삽입 작업은 실패하는 검색을 한 번 수행하므로 O(logn)이 든다. 오버플로가 발생하지 않으면 상수 시간이 든다. 하지만 오버플로가 반복적으로 발생하면 최악의 경우 O(logn)이다. 삭제 작업은 직후 원소를 찾기 위해 O(logn)의 시간이 들 수 있다.
